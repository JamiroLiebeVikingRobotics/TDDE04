import bpy
from mathutils import Vector
from random import uniform 

art = bpy.data.objects["art"]
lights = list(bpy.data.collections["lights"].objects)
#Dis = distance that light can spawn from object art
dis = 6
artLoc = art.location
newLights = []
positions = []


def randomVec():
    r = Vector((uniform(artLoc[0]-dis,artLoc[0]+dis), uniform(artLoc[1]-dis,artLoc[1]+dis), uniform(0,12)))
    while r.magnitude == 0.0:
        r = Vector((uniform(artLoc[0]-dis,artLoc[0]+dis), uniform(artLoc[1]-dis,artLoc[1]+dis), uniform(0,12)))
    return r

def is_inside(obj, p):
    result, point, normal, face_id = obj.closest_point_on_mesh(p)
    local_p = obj.matrix_world.inverted()@p
    p2 = point-local_p
    v = p2.dot(normal)
    return normal.magnitude != 0.0 and v > 0.0

def make2d(vec):
    v = Vector((vec[0],vec[1], 0))
    return v

def newPositions():
    while True:
        while len(positions) < 3:
            newPos = randomVec()
            if is_inside(art, newPos) == False:
                positions.append(newPos)
        sum = (make2d(positions[0])+ make2d(positions[1])+make2d(positions[2])).magnitude
        if sum > 0.2:
            positions.clear()
        else:
            return positions
            print(sum)
            break

positions = newPositions()
print(positions)

lights[0].location = positions[0]
lights[1].location = positions[1]
lights[2].location = positions[2]
